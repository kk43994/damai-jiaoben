# 演出详情页监控 - 技术可行性分析

## 核心问题
如何在演出详情页实时检测"购买按钮从不可点击变为可点击"这个状态变化？

---

## 方案1：Page Source XML文本监控 ⭐⭐⭐⭐⭐

### 原理
```python
page_source = driver.page_source  # 获取UI的XML结构
if '立即购买' in page_source and 'clickable="true"' in page_source:
    # 检测到可购买
```

### 技术细节
- 每次调用`page_source`约耗时：100-300ms
- XML大小：通常20-50KB
- 可检测所有UI文本变化

### 优点
✅ 不依赖图像处理
✅ 能检测文本+可点击状态
✅ 性能开销小
✅ 代码简单

### 缺点
❌ 需要保持Appium session
❌ 如果按钮是纯图片(无文本)检测不到
❌ page_source调用有一定延迟

### 成功率：90%
### 实现难度：★☆☆☆☆ (极简单)
### 推荐指数：⭐⭐⭐⭐⭐

---

## 方案2：坐标盲点循环点击 ⭐⭐⭐⭐

### 原理
```python
while True:
    driver.tap([(360, 1200)])  # 购买按钮固定坐标
    time.sleep(0.3)  # 每0.3秒点一次
    # 如果成功进入下一页面则停止
```

### 技术细节
- 点击速度：约3次/秒
- 不需要任何检测逻辑
- 依赖坐标准确性

### 优点
✅ 响应速度最快（无检测延迟）
✅ 代码极简
✅ 不依赖元素识别
✅ 适合秒杀场景

### 缺点
❌ 开售前会持续失败点击
❌ 坐标不准确会失效
❌ 可能误触其他元素

### 成功率：85%（坐标准确时）
### 实现难度：★☆☆☆☆ (最简单)
### 推荐指数：⭐⭐⭐⭐

---

## 方案3：ADB UIAutomator独立监控 ⭐⭐⭐⭐

### 原理
```bash
# 不依赖Appium，使用ADB原生命令
adb shell uiautomator dump /sdcard/window_dump.xml
adb pull /sdcard/window_dump.xml ui.xml
# Python解析XML查找"立即购买"
```

### 技术细节
- dump速度：约200-500ms
- 完全独立于Appium
- 需要XML解析库

### 优点
✅ 不需要保持Appium session
✅ 更稳定，不会session超时
✅ 可以多进程并行
✅ 资源占用小

### 缺点
❌ dump速度较慢
❌ 需要额外的XML解析
❌ 文件IO开销

### 成功率：85%
### 实现难度：★★☆☆☆ (需要文件操作)
### 推荐指数：⭐⭐⭐⭐

---

## 方案4：HTTP抓包监控 ⭐⭐⭐⭐⭐ (理论最优)

### 原理
```
监控App的网络请求 → 检测到"查询票档"API返回状态变化 → 直接抢票
```

### 技术细节
- 需要设置代理（mitmproxy/Charles）
- 监控App发送的HTTP/HTTPS请求
- 检测到API返回"有票"则触发

### 优点
✅ 最快速度（比UI刷新更早）
✅ 不依赖UI元素
✅ 可以直接调用API抢票
✅ 准确率最高

### 缺点
❌ 需要抓包工具
❌ HTTPS需要证书
❌ 可能有反爬虫检测
❌ 实现复杂度高

### 成功率：95%（如果能绕过反爬）
### 实现难度：★★★★☆ (较复杂)
### 推荐指数：⭐⭐⭐⭐⭐ (技术门槛高)

---

## 方案5：混合策略 (Page Source + 盲点) ⭐⭐⭐⭐⭐

### 原理
```python
while True:
    # 1. 快速检测
    if '立即购买' in driver.page_source:
        # 2. 立即点击坐标
        driver.tap([(360, 1200)])
        break
    time.sleep(0.5)
```

### 技术细节
- 结合检测的准确性和点击的速度
- 双重保险机制

### 优点
✅ 准确性高
✅ 速度快
✅ 容错性强

### 缺点
❌ 代码稍复杂

### 成功率：95%
### 实现难度：★★☆☆☆
### 推荐指数：⭐⭐⭐⭐⭐

---

## 方案6：WebDriver Wait智能等待 ⭐⭐⭐

### 原理
```python
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

# 智能等待直到按钮可点击
element = WebDriverWait(driver, 300).until(
    EC.element_to_be_clickable((AppiumBy.XPATH, "//*[@text='立即购买']"))
)
element.click()
```

### 优点
✅ Selenium内置功能
✅ 自动重试
✅ 代码优雅

### 缺点
❌ 依赖元素定位
❌ 如果元素不存在会超时

### 成功率：80%
### 实现难度：★★☆☆☆
### 推荐指数：⭐⭐⭐

---

## 终极方案对比表

| 方案 | 速度 | 准确性 | 稳定性 | 难度 | 推荐 |
|------|------|--------|--------|------|------|
| Page Source监控 | 快 | 高 | 高 | 低 | ⭐⭐⭐⭐⭐ |
| 坐标盲点 | 极快 | 中 | 中 | 极低 | ⭐⭐⭐⭐ |
| ADB UIAutomator | 中 | 高 | 极高 | 中 | ⭐⭐⭐⭐ |
| HTTP抓包 | 极快 | 极高 | 中 | 高 | ⭐⭐⭐⭐⭐ |
| 混合策略 | 快 | 极高 | 高 | 中 | ⭐⭐⭐⭐⭐ |
| WebDriver Wait | 快 | 高 | 中 | 低 | ⭐⭐⭐ |

---

## 实战建议

### 如果是新手：
→ 使用**方案1 (Page Source)** 或 **方案2 (坐标盲点)**

### 如果追求极致：
→ 使用**方案4 (HTTP抓包)** 或 **方案5 (混合策略)**

### 如果要最稳定：
→ 使用**方案3 (ADB UIAutomator)** 或 **方案5 (混合)**

---

## 现成代码

1. `monitor_page_source.py` - 方案1实现
2. `monitor_detail_page.py` - 方案6实现
3. 方案2、5需要根据实际坐标编写
