# 健壮坐标方案使用指南

## 概述

这是一套健壮的坐标点击方案，包含以下特性：

### 核心特性

1. **多分辨率自适应** - 自动适配不同设备分辨率
2. **智能重试机制** - 点击失败自动重试
3. **随机偏移** - 防止检测的随机点击
4. **人性化延迟** - 模拟真人操作
5. **点击验证** - 验证点击是否成功
6. **备用方案** - 主坐标失败自动尝试备用坐标
7. **序列点击** - 按流程自动执行多个步骤

## 文件结构

```
ticket-purchase/
├── coordinate_manager.py       # 坐标管理器
├── adaptive_clicker.py         # 自适应点击器
├── coordinates.json            # 坐标配置文件
└── 坐标方案使用指南.md         # 本文档
```

## 快速开始

### 1. 准备坐标配置文件

创建 `coordinates.json`：

```json
{
  "base_resolution": [720, 1280],
  "coordinates": {
    "search_entry": [315, 97],
    "buy_button": [464, 1227],
    "session_1": [209, 435],
    "price_lowest": [169, 659],
    "confirm_button": [558, 1233]
  }
}
```

### 2. 基础使用

```python
from coordinate_manager import CoordinateManager
from adaptive_clicker import AdaptiveClicker

# 初始化
coord_manager = CoordinateManager("coordinates.json")
coord_manager.set_device_resolution(720, 1280)  # 设置设备分辨率

# 创建点击器
clicker = AdaptiveClicker(driver, coord_manager)

# 简单点击
clicker.click("buy_button", wait=1.0)
```

### 3. 高级用法

#### 点击序列

```python
# 定义序列
sequence = [
    ("search_entry", 1.0),
    ("search_result_1", 2.0),
    ("buy_button", 1.5),
    ("session_1", 0.5),
    ("price_lowest", 0.5),
    ("confirm_button", 1.0)
]

# 执行序列
clicker.click_sequence(sequence)
```

#### 智能点击（带备用方案）

```python
# 主坐标失败自动尝试备用坐标
clicker.smart_click(
    primary="buy_button",
    fallbacks=["buy_button_bottom", "submit_order"],
    wait=1.0
)
```

#### 带验证的点击

```python
def verify_page_changed():
    return "演出详情" in driver.page_source

clicker.click("show_item_1", wait=2.0, verify=verify_page_changed)
```

#### 持续重试直到成功

```python
def verify_success():
    return "购买成功" in driver.page_source

# 最多尝试10次，直到验证成功
clicker.click_until_success(
    "confirm_button",
    verify=verify_success,
    max_attempts=10
)
```

## 坐标配置详解

### 配置文件格式

```json
{
  "base_resolution": [720, 1280],  // 基准分辨率
  "coordinates": {
    // 坐标名称: [x, y]
    "buy_button": [464, 1227],

    // 支持多个备选坐标
    "buy_button_alt": [360, 1200]
  },
  "aliases": {
    // 别名映射
    "立即购买": "buy_button",
    "确定": "confirm_button"
  }
}
```

### 推荐的坐标命名规范

```
# 页面导航
- search_entry: 搜索入口
- city_selector: 城市选择

# 搜索结果
- search_result_1/2/3: 搜索结果第1/2/3个

# 详情页
- buy_button: 购买按钮
- buy_button_bottom: 底部购买按钮（备用）

# 场次选择
- session_1/2/3: 场次1/2/3
- session_any: 任意场次

# 票档选择
- price_lowest: 最低价
- price_highest: 最高价
- price_1/2/3: 票档1/2/3

# 确认按钮
- confirm_button: 确认
- submit_order: 提交订单
- retry_button: 重试按钮
```

## 完整抢票示例

### 示例 1: 基础抢票流程

```python
from coordinate_manager import CoordinateManager
from adaptive_clicker import AdaptiveClicker

# 初始化
coord_manager = CoordinateManager("coordinates.json")
coord_manager.set_device_resolution(720, 1280)
clicker = AdaptiveClicker(driver, coord_manager)

# 配置人性化参数
clicker.random_offset = True  # 启用随机偏移
clicker.offset_range = 5      # 偏移5像素
clicker.human_delay = True    # 人性化延迟

# 执行抢票
sequence = [
    ("search_entry", 1.0),
    ("search_result_1", 2.0),
    ("buy_button", 1.5),
    ("session_1", 0.5),
    ("price_lowest", 0.5),
    ("confirm_button", 1.0)
]

success = clicker.click_sequence(sequence, stop_on_failure=True)
if success:
    print("抢票成功！")
else:
    print("抢票失败")
```

### 示例 2: 带重试的抢票

```python
# 持续点击重试按钮
max_retries = 100
for i in range(max_retries):
    print(f"尝试抢票 第{i+1}次...")

    # 点击购买
    if clicker.click("buy_button", wait=1.0):
        # 选择场次和票档
        clicker.click("session_1", wait=0.5)
        clicker.click("price_lowest", wait=0.5)

        # 点击确认
        if clicker.click("confirm_button", wait=1.0):
            # 检查是否成功
            page_source = driver.page_source
            if "订单" in page_source:
                print("抢票成功!")
                break
            elif "排队" in page_source or "重试" in page_source:
                # 点击重试
                clicker.click("retry_button", wait=0.5)
```

### 示例 3: 多种票档策略

```python
# 尝试多个票档（从低到高）
price_options = ["price_lowest", "price_2", "price_3", "price_highest"]

for price in price_options:
    print(f"尝试票档: {price}")
    if clicker.click(price, wait=0.5):
        if clicker.click("confirm_button", wait=1.0):
            # 检查是否成功
            if "成功" in driver.page_source:
                print(f"成功选择票档: {price}")
                break
```

## 在 GUI 中使用

### 1. 导入坐标配置

在GUI中点击"导入坐标配置"按钮，选择你的 `coordinates.json` 文件。

### 2. 编辑坐标

点击"编辑坐标"按钮，会打开记事本编辑坐标文件。

### 3. 自动应用

导入后，GUI会自动使用这些坐标进行点击操作。

## 如何录制坐标

### 方法 1: 使用 GUI 的鼠标坐标显示

1. 在 GUI 的截图区域移动鼠标
2. 底部会显示当前坐标（已自动转换为真实设备坐标）
3. 记录需要的坐标点

### 方法 2: 使用 Appium Inspector

1. 打开 Appium Inspector
2. 连接到设备
3. 点击元素查看坐标
4. 记录坐标到配置文件

### 方法 3: 截图测量

1. 截取设备屏幕
2. 使用画图工具测量像素坐标
3. 记录到配置文件

## 最佳实践

### 1. 多设备适配

```json
{
  "base_resolution": [720, 1280],
  "coordinates": {
    "buy_button": [464, 1227]
  }
}
```

所有坐标基于 720x1280 录制，程序会自动缩放到实际设备分辨率。

### 2. 提供备用坐标

```python
# 主坐标 + 多个备用坐标
clicker.smart_click(
    "buy_button",
    ["buy_button_alt", "buy_button_bottom"],
    wait=1.0
)
```

### 3. 使用区域点击

```python
# 在坐标附近随机点击（50像素范围内）
coord_manager.click_random_in_area(
    driver,
    "buy_button",
    area_size=50
)
```

### 4. 验证点击结果

```python
def verify():
    return "详情页" in driver.page_source

clicker.click("show_item_1", wait=2.0, verify=verify)
```

## 故障排查

### 问题 1: 点击位置不准确

**解决方案：**
1. 检查设备分辨率是否设置正确
2. 验证基准分辨率是否匹配坐标录制时的分辨率
3. 增加偏移范围或禁用随机偏移

### 问题 2: 点击无响应

**解决方案：**
1. 增加等待时间
2. 增加重试次数
3. 检查坐标是否正确

### 问题 3: 点击速度太快

**解决方案：**
```python
clicker.human_delay = True
clicker.delay_range = (0.3, 0.8)  # 增加延迟范围
```

## 进阶技巧

### 1. 动态坐标计算

```python
# 基于屏幕百分比计算坐标
screen_width = 720
screen_height = 1280

center_x = screen_width // 2
bottom_y = int(screen_height * 0.95)
```

### 2. 坐标偏移策略

```python
# 点击按钮上方（避开遮挡元素）
clicker.click_with_offset("buy_button", offset_y=-50, wait=1.0)
```

### 3. 滑动操作

```python
# 向下滑动
coord_manager.swipe_coordinate(
    driver,
    from_name="screen_top",
    to_name="screen_bottom",
    duration=500
)
```

## 总结

这套健壮的坐标方案具有以下优势：

✅ **自适应** - 支持多种分辨率
✅ **容错** - 自动重试和备用方案
✅ **智能** - 验证点击结果
✅ **人性化** - 随机偏移和延迟
✅ **可维护** - JSON 配置易于编辑
✅ **可扩展** - 易于添加新坐标和策略

使用这套方案，你的抢票成功率和稳定性将大大提升！
